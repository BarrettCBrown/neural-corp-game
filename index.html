<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neural Corp: The Architect</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;700;900&family=Rajdhani:wght@300;500;700&display=swap');

        :root {
            --neon-blue: #00f3ff;
            --neon-pink: #ff00ff;
            --neon-green: #0aff00;
            --neon-amber: #ffaa00;
            --bg-dark: #050510;
            --glass: rgba(10, 15, 30, 0.85);
        }

        body {
            background-color: var(--bg-dark);
            color: #e2e8f0;
            font-family: 'Rajdhani', sans-serif;
            overflow: hidden;
            margin: 0;
            padding: 0;
        }

        h1, h2, h3, .hud-value {
            font-family: 'Orbitron', sans-serif;
            text-transform: uppercase;
        }

        canvas {
            display: block;
        }

        /* Scanline effect */
        .scanlines {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(
                to bottom,
                rgba(255,255,255,0),
                rgba(255,255,255,0) 50%,
                rgba(0,0,0,0.1) 50%,
                rgba(0,0,0,0.1)
            );
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 5;
        }

        .glass-panel {
            background: var(--glass);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(0, 243, 255, 0.2);
            box-shadow: 0 0 20px rgba(0, 243, 255, 0.1);
        }

        .btn-neon {
            background: rgba(0, 243, 255, 0.1);
            border: 1px solid var(--neon-blue);
            color: var(--neon-blue);
            transition: all 0.3s ease;
            text-shadow: 0 0 5px var(--neon-blue);
            font-family: 'Orbitron', sans-serif;
            letter-spacing: 1px;
        }

        .btn-neon:hover:not(:disabled) {
            background: var(--neon-blue);
            color: #000;
            box-shadow: 0 0 20px var(--neon-blue);
        }
        
        .btn-neon:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            border-color: #555;
            color: #555;
            text-shadow: none;
        }

        .node-label {
            position: absolute;
            transform: translate(-50%, -150%);
            font-size: 10px;
            color: rgba(255,255,255,0.7);
            pointer-events: none;
            text-shadow: 0 0 2px black;
            white-space: nowrap;
        }

        /* Custom Scrollbar */
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: #0b1120; }
        ::-webkit-scrollbar-thumb { background: #1e293b; border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: var(--neon-blue); }
        
        @keyframes pulse-red {
            0% { box-shadow: 0 0 0 0 rgba(255, 0, 0, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(255, 0, 0, 0); }
            100% { box-shadow: 0 0 0 0 rgba(255, 0, 0, 0); }
        }
        
        .hazard-border {
            border: 1px solid #ff3333;
            animation: pulse-red 2s infinite;
        }
    </style>
</head>
<body class="h-screen w-screen flex flex-col relative">

    <div class="scanlines"></div>

    <!-- MAIN HUD -->
    <div class="absolute top-0 left-0 w-full p-4 z-20 flex justify-between pointer-events-none">
        <div class="glass-panel p-4 rounded-br-3xl pointer-events-auto">
            <h1 class="text-2xl text-cyan-400 mb-1 flex items-center gap-2">
                <span class="text-3xl">üß†</span> NEURAL CORP
            </h1>
            <div class="text-xs text-cyan-100 tracking-widest opacity-70">COGNITIVE DIVISION ARCHITECT</div>
            <div class="mt-4 space-y-2 text-sm">
                <div class="flex justify-between w-48">
                    <span class="text-gray-400">EPOCH (Cycle):</span>
                    <span id="epoch-display" class="hud-value text-white">0</span>
                </div>
                <div class="flex justify-between w-48">
                    <span class="text-gray-400">KPI GAP (Loss):</span>
                    <span id="loss-display" class="hud-value text-red-400">0.000</span>
                </div>
                <div class="flex justify-between w-48">
                    <span class="text-gray-400">ACCURACY:</span>
                    <span id="acc-display" class="hud-value text-green-400">0%</span>
                </div>
            </div>
        </div>

        <!-- LEVEL OBJECTIVE -->
        <div class="glass-panel p-4 rounded-bl-3xl pointer-events-auto max-w-md text-right">
            <h2 class="text-amber-400 text-lg mb-1" id="level-title">LEVEL 1: THE STARTUP</h2>
            <p class="text-xs text-gray-300 mb-2 italic" id="level-desc">
                Establish the first lines of communication. Train a simple Linear Perceptron.
            </p>
            <div id="objective-container" class="text-sm font-bold text-white border-t border-gray-700 pt-2 mt-2">
                GOAL: Reach 95% Accuracy
            </div>
        </div>
    </div>

    <!-- CONTROLS BOTTOM -->
    <div class="absolute bottom-0 left-0 w-full p-6 z-20 flex justify-center pointer-events-none">
        <div class="glass-panel px-8 py-4 rounded-full pointer-events-auto flex items-center gap-6">
            
            <div class="flex flex-col items-center">
                <span class="text-[10px] text-gray-400 mb-1 uppercase tracking-wider">Learning Rate (Change Velocity)</span>
                <input type="range" id="lr-slider" min="0.001" max="0.1" step="0.001" value="0.01" class="w-32 accent-cyan-500">
            </div>

            <div class="h-8 w-px bg-gray-700"></div>

            <button id="btn-step" class="btn-neon px-6 py-2 rounded font-bold flex items-center gap-2">
                <span>‚ñ∂</span> RUN BATCH (Forward)
            </button>
            
            <button id="btn-train" class="btn-neon px-6 py-2 rounded font-bold flex items-center gap-2 border-amber-500 text-amber-500 hover:shadow-amber-500/50">
                <span>‚ö°</span> TRAIN (Backprop)
            </button>

            <div class="h-8 w-px bg-gray-700"></div>

            <button id="btn-reset" class="px-4 py-2 text-xs text-red-400 hover:text-red-300 border border-red-900/50 hover:bg-red-900/20 rounded transition">
                RESET ORG
            </button>
        </div>
    </div>

    <!-- CHARTS OVERLAY RIGHT -->
    <div class="absolute top-1/2 right-4 transform -translate-y-1/2 z-10 w-64 pointer-events-none">
        <div class="glass-panel p-2 rounded mb-4 pointer-events-auto">
            <div class="text-[10px] text-center text-gray-400 mb-1 uppercase">Performance Trend</div>
            <canvas id="lossChart" height="150"></canvas>
        </div>
        <div id="bias-meter-container" class="glass-panel p-2 rounded pointer-events-auto hidden">
            <div class="text-[10px] text-center text-gray-400 mb-1 uppercase">Systemic Bias Meter</div>
            <div class="w-full bg-gray-800 h-2 rounded overflow-hidden">
                <div id="bias-bar" class="h-full bg-red-500 transition-all duration-500" style="width: 0%"></div>
            </div>
            <div class="flex justify-between text-[9px] text-gray-500 mt-1">
                <span>Neutral</span>
                <span>Critical</span>
            </div>
        </div>
    </div>

    <!-- CANVAS LAYER -->
    <canvas id="gameCanvas" class="w-full h-full absolute top-0 left-0 z-0"></canvas>

    <!-- MODAL / TUTORIAL -->
    <div id="modal-overlay" class="fixed inset-0 bg-black/80 z-50 flex items-center justify-center p-4">
        <div class="glass-panel max-w-2xl w-full p-8 rounded-xl border-2 border-cyan-500/30 relative">
            <div class="absolute -top-3 -left-3 w-6 h-6 border-t-2 border-l-2 border-cyan-400"></div>
            <div class="absolute -bottom-3 -right-3 w-6 h-6 border-b-2 border-r-2 border-cyan-400"></div>
            
            <h2 id="modal-title" class="text-3xl text-white mb-4 border-b border-gray-700 pb-2">WELCOME ARCHITECT</h2>
            <div id="modal-content" class="text-gray-300 space-y-4 leading-relaxed font-light text-lg">
                <p>You have been hired to design the <strong>Cognitive Division</strong>.</p>
                <p>Your goal: Build a synthetic organization (Neural Network) that learns from data.</p>
                <ul class="list-disc pl-5 space-y-2 text-sm text-cyan-200">
                    <li><strong>Architecture:</strong> The Org Chart (Nodes & Layers).</li>
                    <li><strong>Weights:</strong> Relationships & Trust (Lines).</li>
                    <li><strong>Training:</strong> The cycle of Action (Forward Pass) and Feedback (Backpropagation).</li>
                </ul>
            </div>
            <div class="mt-8 flex justify-end">
                <button id="modal-btn" class="btn-neon px-8 py-3 text-xl rounded">INITIALIZE SYSTEM</button>
            </div>
        </div>
    </div>

    <!-- LOGIC -->
    <script>
        // --- OD / AI DICTIONARY ---
        const DICTIONARY = {
            'Node': 'Agent',
            'Layer': 'Dept',
            'Weight': 'Trust Level',
            'Gradient': 'Feedback Report',
            'Loss': 'Performance Gap',
            'Backprop': 'Realignment'
        };

        // --- ENGINE & MATH ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        let width, height;

        // Activation Functions
        const sigmoid = x => 1 / (1 + Math.exp(-x));
        const sigmoidDeriv = x => x * (1 - x);
        const relu = x => Math.max(0, x);
        const reluDeriv = x => x > 0 ? 1 : 0;
        
        // Simple Neural Network Class
        class NeuralNetwork {
            constructor(layerSizes) {
                this.layers = [];
                this.layerSizes = layerSizes;
                
                // Initialize structure
                for (let i = 0; i < layerSizes.length; i++) {
                    const layer = {
                        neurons: new Float32Array(layerSizes[i]),
                        biases: new Float32Array(layerSizes[i]),
                        errors: new Float32Array(layerSizes[i]),
                        gradients: new Float32Array(layerSizes[i]),
                    };
                    
                    // Randomize biases
                    for(let j=0; j<layerSizes[i]; j++) layer.biases[j] = Math.random() * 2 - 1;
                    
                    this.layers.push(layer);
                }

                // Initialize Weights (connections between layers)
                this.weights = []; // Array of matrices
                for (let i = 0; i < layerSizes.length - 1; i++) {
                    const rows = layerSizes[i+1];
                    const cols = layerSizes[i];
                    const weightMatrix = [];
                    for(let r=0; r<rows; r++) {
                        const row = new Float32Array(cols);
                        for(let c=0; c<cols; c++) row[c] = Math.random() * 2 - 1; // Random -1 to 1
                        weightMatrix.push(row);
                    }
                    this.weights.push(weightMatrix);
                }
            }

            forward(inputs) {
                // Set input layer
                for(let i=0; i<inputs.length; i++) {
                    this.layers[0].neurons[i] = inputs[i];
                }

                // Propagate
                for(let i=0; i<this.weights.length; i++) {
                    const prevLayer = this.layers[i].neurons;
                    const nextLayer = this.layers[i+1];
                    const weights = this.weights[i];

                    for(let j=0; j<nextLayer.neurons.length; j++) {
                        let sum = nextLayer.biases[j];
                        for(let k=0; k<prevLayer.length; k++) {
                            sum += prevLayer[k] * weights[j][k];
                        }
                        // Activation (Sigmoid for simplicity in visualizer)
                        nextLayer.neurons[j] = sigmoid(sum);
                    }
                }
                return this.layers[this.layers.length-1].neurons;
            }

            train(inputs, targets, learningRate) {
                // 1. Forward
                const outputs = this.forward(inputs);

                // 2. Calculate Output Error (Loss Gradient)
                const outputLayerIdx = this.layers.length - 1;
                const outputLayer = this.layers[outputLayerIdx];
                
                for(let i=0; i<outputLayer.neurons.length; i++) {
                    const output = outputLayer.neurons[i];
                    const error = targets[i] - output; // Simple error
                    outputLayer.errors[i] = error;
                    // Gradient = error * derivative
                    outputLayer.gradients[i] = error * sigmoidDeriv(output);
                }

                // 3. Backpropagate
                for(let i = this.weights.length - 1; i >= 0; i--) {
                    const weights = this.weights[i];
                    const prevLayer = this.layers[i];
                    const nextLayer = this.layers[i+1];

                    // Calculate gradients for current layer (hidden)
                    if (i > 0) { // No error calc needed for input layer
                         for(let j=0; j<prevLayer.neurons.length; j++) {
                             let errorSum = 0;
                             for(let k=0; k<nextLayer.neurons.length; k++) {
                                 errorSum += nextLayer.errors[k] * weights[k][j];
                             }
                             prevLayer.errors[j] = errorSum;
                             prevLayer.gradients[j] = errorSum * sigmoidDeriv(prevLayer.neurons[j]);
                         }
                    }

                    // Update Weights
                    for(let j=0; j<nextLayer.neurons.length; j++) {
                        for(let k=0; k<prevLayer.neurons.length; k++) {
                            const delta = learningRate * nextLayer.gradients[j] * prevLayer.neurons[k];
                            weights[j][k] += delta;
                        }
                        // Update Biases
                        nextLayer.biases[j] += learningRate * nextLayer.gradients[j];
                    }
                }
                
                // Return simple MSE for visualization
                let sumError = 0;
                for(let i=0; i<outputs.length; i++) sumError += Math.pow(targets[i] - outputs[i], 2);
                return sumError / outputs.length;
            }
        }

        // --- GAME & VISUALIZER STATE ---
        const Game = {
            level: 1,
            epoch: 0,
            accuracy: 0,
            lossHistory: [],
            isTraining: false,
            learningRate: 0.05,
            nn: null,
            data: [], // Current dataset
            particles: [], // Visual effects
            nodes: [], // Visual coordinates
            
            levels: [
                {
                    id: 1,
                    name: "THE STARTUP",
                    desc: "Train a simple hierarchy. Input: 2 factors. Output: 1 decision.",
                    structure: [2, 1], // Simple Perceptron
                    goalAcc: 95,
                    biasEvent: false,
                    genData: () => {
                        // Simple logic: AND gate behavior
                        // Input > 0.5 & Input > 0.5 -> 1
                        const d = [];
                        for(let i=0; i<50; i++) {
                            const a = Math.round(Math.random());
                            const b = Math.round(Math.random());
                            d.push({ input: [a, b], output: [a && b ? 1 : 0] });
                        }
                        return d;
                    }
                },
                {
                    id: 2,
                    name: "THE EXPANSION",
                    desc: "The problem is non-linear (XOR). A simple hierarchy fails. We need Middle Management (Hidden Layer).",
                    structure: [2, 4, 1], 
                    goalAcc: 90,
                    biasEvent: false,
                    genData: () => {
                        // XOR Logic
                        const d = [];
                        for(let i=0; i<50; i++) {
                            const a = Math.round(Math.random());
                            const b = Math.round(Math.random());
                            d.push({ input: [a, b], output: [a !== b ? 1 : 0] });
                        }
                        return d;
                    }
                },
                {
                    id: 3,
                    name: "THE BIAS TRAP",
                    desc: "The structure is sound, but the 'History' (Data) is flawed. Minority cases are being rejected.",
                    structure: [3, 5, 2],
                    goalAcc: 85,
                    biasEvent: true,
                    genData: () => {
                        // Biased Data: Feature 3 (Background) determines outcome unfairly
                        const d = [];
                        for(let i=0; i<100; i++) {
                            const merit = Math.random();
                            const background = Math.random() > 0.9 ? 1 : 0; // Minority group
                            
                            let decision = 0;
                            // True logic: Merit > 0.5 should be YES
                            // Biased History: If background=1, we rejected them often even with merit
                            if (background === 1) {
                                decision = (merit > 0.8) ? 1 : 0; // Harder for minority
                            } else {
                                decision = (merit > 0.4) ? 1 : 0; // Easier for majority
                            }
                            
                            d.push({ input: [merit, Math.random(), background], output: [decision, background] });
                        }
                        return d;
                    }
                }
            ],

            initLevel: function(lvlIdx) {
                this.level = lvlIdx + 1;
                const config = this.levels[lvlIdx];
                this.nn = new NeuralNetwork(config.structure);
                this.data = config.genData();
                this.epoch = 0;
                this.lossHistory = [];
                this.particles = [];
                
                // UI Updates
                document.getElementById('level-title').innerText = `LEVEL ${this.level}: ${config.name}`;
                document.getElementById('level-desc').innerText = config.desc;
                document.getElementById('objective-container').innerText = `GOAL: ${config.biasEvent ? 'Reduce Bias < 10%' : `Accuracy > ${config.goalAcc}%`}`;
                
                if(config.biasEvent) document.getElementById('bias-meter-container').classList.remove('hidden');
                else document.getElementById('bias-meter-container').classList.add('hidden');

                this.setupVisualNodes();
                updateChart();
            },

            setupVisualNodes: function() {
                this.nodes = [];
                const layers = this.nn.layerSizes;
                const layerGap = width / (layers.length + 1);
                
                for(let l=0; l<layers.length; l++) {
                    const count = layers[l];
                    const nodeGap = height / (count + 1);
                    for(let n=0; n<count; n++) {
                        this.nodes.push({
                            x: layerGap * (l + 1),
                            y: nodeGap * (n + 1),
                            layer: l,
                            index: n,
                            value: 0, // Current activation
                            bias: this.nn.layers[l].biases[n]
                        });
                    }
                }
            },

            trainBatch: function(animate = true) {
                // Train on entire dataset (1 Epoch)
                let totalLoss = 0;
                let correct = 0;
                
                // Shuffle data
                this.data.sort(() => Math.random() - 0.5);

                this.data.forEach(item => {
                    const loss = this.nn.train(item.input, item.output, this.learningRate);
                    totalLoss += loss;
                    
                    // Check accuracy (binary classification assumed for simplicity)
                    const output = this.nn.layers[this.nn.layers.length-1].neurons[0];
                    const prediction = output > 0.5 ? 1 : 0;
                    if(prediction === item.output[0]) correct++;
                });

                const avgLoss = totalLoss / this.data.length;
                this.lossHistory.push(avgLoss);
                if(this.lossHistory.length > 50) this.lossHistory.shift();
                
                this.accuracy = (correct / this.data.length) * 100;
                this.epoch++;

                // Visual Effects
                if(animate) {
                    this.spawnParticles('forward');
                    setTimeout(() => this.spawnParticles('backward'), 300);
                }

                // Check Win Condition
                const currentConfig = this.levels[this.level - 1];
                if(this.accuracy >= currentConfig.goalAcc && !currentConfig.biasEvent) {
                    this.triggerWin();
                }
            },

            spawnParticles: function(type) {
                // Create visual particles moving along connections
                const weights = this.nn.weights;
                
                for(let l=0; l<weights.length; l++) {
                    const currentLayerNodes = this.nodes.filter(n => n.layer === l);
                    const nextLayerNodes = this.nodes.filter(n => n.layer === l+1);
                    
                    for(let i=0; i<currentLayerNodes.length; i++) {
                        for(let j=0; j<nextLayerNodes.length; j++) {
                            const w = weights[l][j][i];
                            // Only spawn if weight is significant or random chance
                            if(Math.abs(w) > 0.1 || Math.random() > 0.8) {
                                const start = type === 'forward' ? currentLayerNodes[i] : nextLayerNodes[j];
                                const end = type === 'forward' ? nextLayerNodes[j] : currentLayerNodes[i];
                                
                                this.particles.push({
                                    x: start.x,
                                    y: start.y,
                                    tx: end.x,
                                    ty: end.y,
                                    progress: 0,
                                    speed: 0.05 + Math.random() * 0.05,
                                    color: type === 'forward' ? '#0aff00' : '#ffffff', // Green forward, White backprop
                                    size: type === 'forward' ? 2 : 3
                                });
                            }
                        }
                    }
                }
            },

            triggerWin: function() {
                if(this.level < 3) {
                    showModal(`LEVEL ${this.level} COMPLETE`, 
                        `Organization Optimized. Performance Gap closed.<br>Ready to expand structure?`, 
                        "NEXT LEVEL", 
                        () => this.initLevel(this.level));
                } else {
                    showModal("SYSTEM OPTIMIZED", "You have mastered the art of growing intelligence.<br>The Cognitive Division is ready for deployment.", "REPLAY", () => location.reload());
                }
            }
        };

        // --- VISUALIZATION LOOP ---
        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
            if(Game.nn) Game.setupVisualNodes();
        }
        window.addEventListener('resize', resize);

        function draw() {
            ctx.fillStyle = '#050510';
            ctx.fillRect(0, 0, width, height);

            if(!Game.nn) return requestAnimationFrame(draw);

            // 1. Draw Connections (Weights)
            for(let l=0; l<Game.nn.weights.length; l++) {
                const currentLayerNodes = Game.nodes.filter(n => n.layer === l);
                const nextLayerNodes = Game.nodes.filter(n => n.layer === l+1);
                
                for(let i=0; i<currentLayerNodes.length; i++) {
                    for(let j=0; j<nextLayerNodes.length; j++) {
                        const weight = Game.nn.weights[l][j][i];
                        const from = currentLayerNodes[i];
                        const to = nextLayerNodes[j];
                        
                        ctx.beginPath();
                        ctx.moveTo(from.x, from.y);
                        ctx.lineTo(to.x, to.y);
                        
                        // Style based on Weight
                        const strength = Math.abs(weight);
                        ctx.lineWidth = Math.min(6, Math.max(0.5, strength * 2));
                        
                        if(weight > 0) ctx.strokeStyle = `rgba(0, 243, 255, ${Math.min(0.8, strength)})`; // Blue (Trust)
                        else ctx.strokeStyle = `rgba(255, 0, 80, ${Math.min(0.8, strength)})`; // Red (Distrust)
                        
                        ctx.stroke();
                    }
                }
            }

            // 2. Draw Particles (Data flow)
            for(let i=Game.particles.length-1; i>=0; i--) {
                const p = Game.particles[i];
                p.progress += p.speed;
                
                const currX = p.x + (p.tx - p.x) * p.progress;
                const currY = p.y + (p.ty - p.y) * p.progress;
                
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(currX, currY, p.size, 0, Math.PI*2);
                ctx.fill();

                // Glow
                ctx.shadowBlur = 10;
                ctx.shadowColor = p.color;
                ctx.fill();
                ctx.shadowBlur = 0;

                if(p.progress >= 1) Game.particles.splice(i, 1);
            }

            // 3. Draw Nodes (Agents)
            Game.nodes.forEach(node => {
                // Get real activation value from NN if available
                const val = Game.nn.layers[node.layer].neurons[node.index];
                
                // Base Circle
                ctx.beginPath();
                ctx.arc(node.x, node.y, 15, 0, Math.PI*2);
                ctx.fillStyle = '#1e293b';
                ctx.fill();
                
                // Border
                ctx.lineWidth = 2;
                ctx.strokeStyle = node.layer === 0 ? '#fbbf24' : (node.layer === Game.nn.layers.length-1 ? '#a3e635' : '#00f3ff');
                ctx.stroke();

                // Activation Fill (Inner glow)
                if(val > 0.1) {
                    ctx.beginPath();
                    ctx.arc(node.x, node.y, 15 * val, 0, Math.PI*2);
                    ctx.fillStyle = `rgba(255, 255, 255, ${val * 0.5})`;
                    ctx.fill();
                }

                // Text Label (Role)
                ctx.fillStyle = '#fff';
                ctx.font = '10px Orbitron';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                let role = "H";
                if(node.layer === 0) role = "IN";
                else if(node.layer === Game.nn.layers.length-1) role = "OUT";
                ctx.fillText(role, node.x, node.y);
            });

            // 4. Update HUD Text
            document.getElementById('epoch-display').innerText = Game.epoch;
            const lastLoss = Game.lossHistory.length > 0 ? Game.lossHistory[Game.lossHistory.length-1] : 0;
            document.getElementById('loss-display').innerText = lastLoss.toFixed(4);
            document.getElementById('acc-display').innerText = Math.round(Game.accuracy) + "%";

            // Bias Meter Update (Level 3)
            if(Game.levels[Game.level-1].biasEvent) {
                // Fake bias calc for visual
                const biasVal = Math.max(0, 100 - Game.epoch); // Decreases over time simplistically for demo
                document.getElementById('bias-bar').style.width = biasVal + "%";
            }

            requestAnimationFrame(draw);
        }

        // --- CHART ---
        const ctxChart = document.getElementById('lossChart').getContext('2d');
        let lossChart = new Chart(ctxChart, {
            type: 'line',
            data: {
                labels: [],
                datasets: [{
                    label: 'Gap Analysis (Loss)',
                    data: [],
                    borderColor: '#ff00ff',
                    borderWidth: 1,
                    tension: 0.4,
                    pointRadius: 0
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    x: { display: false },
                    y: { 
                        display: true, 
                        grid: { color: '#333' },
                        ticks: { color: '#666', font: {size: 8} } 
                    }
                },
                plugins: { legend: { display: false } },
                animation: false
            }
        });

        function updateChart() {
            lossChart.data.labels = Game.lossHistory.map((_, i) => i);
            lossChart.data.datasets[0].data = Game.lossHistory;
            lossChart.update();
        }

        // --- UI INTERACTION ---
        const modal = document.getElementById('modal-overlay');
        const modalTitle = document.getElementById('modal-title');
        const modalContent = document.getElementById('modal-content');
        const modalBtn = document.getElementById('modal-btn');

        function showModal(title, content, btnText, action) {
            modalTitle.innerText = title;
            modalContent.innerHTML = content;
            modalBtn.innerText = btnText;
            modalBtn.onclick = () => {
                modal.classList.add('hidden');
                if(action) action();
            };
            modal.classList.remove('hidden');
        }

        document.getElementById('btn-step').addEventListener('click', () => {
            Game.trainBatch(true);
            updateChart();
        });

        document.getElementById('btn-train').addEventListener('click', () => {
            if(Game.isTraining) {
                Game.isTraining = false;
                document.getElementById('btn-train').innerHTML = "<span>‚ö°</span> TRAIN (Backprop)";
                document.getElementById('btn-train').classList.remove('animate-pulse');
            } else {
                Game.isTraining = true;
                document.getElementById('btn-train').innerHTML = "<span>‚è∏</span> PAUSE TRAINING";
                document.getElementById('btn-train').classList.add('animate-pulse');
                loopTraining();
            }
        });

        function loopTraining() {
            if(!Game.isTraining) return;
            Game.trainBatch(true); // Animate particles
            updateChart();
            setTimeout(loopTraining, 200); // Speed of training loop
        }

        document.getElementById('btn-reset').addEventListener('click', () => {
            Game.isTraining = false;
            document.getElementById('btn-train').innerHTML = "<span>‚ö°</span> TRAIN (Backprop)";
            Game.initLevel(Game.level - 1);
        });

        document.getElementById('lr-slider').addEventListener('input', (e) => {
            Game.learningRate = parseFloat(e.target.value);
        });

        // --- BOOTSTRAP ---
        resize();
        
        // Initial Modal Setup
        modalBtn.onclick = () => {
            modal.classList.add('hidden');
            Game.initLevel(0);
            draw();
        };

    </script>
</body>
</html>
