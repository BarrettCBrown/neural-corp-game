<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Neural Corp: The Architect</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;700;900&family=Rajdhani:wght@300;500;700&display=swap');

        :root {
            --neon-blue: #00f3ff;
            --neon-pink: #ff00ff;
            --neon-green: #0aff00;
            --neon-amber: #ffaa00;
            --neon-red: #ff3333;
            --bg-dark: #050510;
            --glass: rgba(10, 15, 30, 0.85);
        }

        body {
            background-color: var(--bg-dark);
            color: #e2e8f0;
            font-family: 'Rajdhani', sans-serif;
            overflow: hidden;
            margin: 0;
            padding: 0;
            height: 100vh;
            height: 100dvh;
            touch-action: none;
        }

        h1, h2, h3, .hud-value {
            font-family: 'Orbitron', sans-serif;
            text-transform: uppercase;
        }

        canvas {
            display: block;
        }

        .scanlines {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(
                to bottom,
                rgba(255,255,255,0),
                rgba(255,255,255,0) 50%,
                rgba(0,0,0,0.1) 50%,
                rgba(0,0,0,0.1)
            );
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 5;
        }

        .glass-panel {
            background: var(--glass);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(0, 243, 255, 0.2);
            box-shadow: 0 0 20px rgba(0, 243, 255, 0.1);
            transition: all 0.3s ease;
        }

        .glass-panel.hazard {
            border-color: var(--neon-red);
            box-shadow: 0 0 20px rgba(255, 51, 51, 0.2);
        }

        .btn-neon {
            background: rgba(0, 243, 255, 0.1);
            border: 1px solid var(--neon-blue);
            color: var(--neon-blue);
            transition: all 0.3s ease;
            text-shadow: 0 0 5px var(--neon-blue);
            font-family: 'Orbitron', sans-serif;
            letter-spacing: 1px;
            touch-action: manipulation;
        }

        .btn-neon:hover:not(:disabled) {
            background: var(--neon-blue);
            color: #000;
            box-shadow: 0 0 20px var(--neon-blue);
        }
        
        .btn-neon:disabled {
            opacity: 0.3;
            cursor: not-allowed;
            filter: grayscale(100%);
        }

        .btn-toggle {
            font-size: 0.75rem;
            padding: 0.25rem 0.75rem;
            border: 1px solid #444;
            color: #888;
            transition: all 0.2s;
            touch-action: manipulation;
        }
        
        .btn-toggle.active {
            background: var(--neon-green);
            color: black;
            border-color: var(--neon-green);
            font-weight: bold;
            box-shadow: 0 0 10px var(--neon-green);
        }

        .btn-toggle.active-danger {
            background: var(--neon-red);
            color: white;
            border-color: var(--neon-red);
            font-weight: bold;
            box-shadow: 0 0 10px var(--neon-red);
        }

        input[type=range] {
            touch-action: pan-x;
        }

        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: #0b1120; }
        ::-webkit-scrollbar-thumb { background: #1e293b; border-radius: 3px; }
    </style>
</head>
<body class="flex flex-col relative select-none">

    <div class="scanlines"></div>

    <!-- MAIN HUD (Top) -->
    <div id="ui-header" class="absolute top-0 left-0 w-full p-2 md:p-4 z-20 flex justify-between pointer-events-none">
        <div class="glass-panel p-3 md:p-4 rounded-br-3xl pointer-events-auto">
            <h1 class="text-xl md:text-2xl text-cyan-400 mb-1 flex items-center gap-2">
                <span class="text-2xl md:text-3xl">üß†</span> <span class="hidden md:inline">NEURAL CORP</span>
            </h1>
            <div class="text-[10px] md:text-xs text-cyan-100 tracking-widest opacity-70">ARCHITECT MODE</div>
            <div class="mt-2 md:mt-4 space-y-1 md:space-y-2 text-xs md:text-sm">
                <div class="flex justify-between w-32 md:w-48">
                    <span class="text-gray-400">EPOCH:</span>
                    <span id="epoch-display" class="hud-value text-white">0</span>
                </div>
                <div class="flex justify-between w-32 md:w-48">
                    <span class="text-gray-400">LOSS (GAP):</span>
                    <span id="loss-display" class="hud-value text-red-400">0.000</span>
                </div>
                <div class="flex justify-between w-32 md:w-48">
                    <span class="text-gray-400">ACCURACY:</span>
                    <span id="acc-display" class="hud-value text-green-400">0%</span>
                </div>
            </div>
        </div>

        <!-- LEVEL OBJECTIVE -->
        <div class="glass-panel p-3 md:p-4 rounded-bl-3xl pointer-events-auto max-w-[200px] md:max-w-md text-right flex flex-col items-end">
            <h2 class="text-amber-400 text-sm md:text-lg mb-1" id="level-title">LEVEL 1</h2>
            <p class="text-[10px] md:text-xs text-gray-300 mb-2 italic hidden md:block" id="level-desc">
                Mission Description
            </p>
            <div id="objective-container" class="text-xs md:text-sm font-bold text-white border-t border-gray-700 pt-2 mt-2 w-full text-right">
                GOAL: 95% ACC
            </div>

            <!-- LEVEL 3 DATA CONTROLS -->
            <div id="data-controls" class="mt-4 hidden flex-col gap-2 items-end w-full">
                <div class="text-[10px] text-gray-400 uppercase tracking-widest mb-1">Training Source</div>
                <div class="flex gap-2">
                    <button id="btn-data-legacy" class="btn-toggle active-danger rounded-l" onclick="Game.setDataSource('legacy')">LEGACY (BIASED)</button>
                    <button id="btn-data-audit" class="btn-toggle rounded-r" onclick="Game.setDataSource('audited')">AUDITED (CLEAN)</button>
                </div>
            </div>
        </div>
    </div>

    <!-- CONTROLS (Bottom) -->
    <div id="ui-footer" class="absolute bottom-0 left-0 w-full p-4 md:p-6 z-20 flex justify-center pointer-events-none">
        <div class="glass-panel px-4 py-3 md:px-8 md:py-4 rounded-xl md:rounded-full pointer-events-auto flex flex-wrap justify-center items-center gap-4 md:gap-6">
            
            <div class="flex flex-col items-center w-full md:w-auto">
                <span class="text-[10px] text-gray-400 mb-1 uppercase tracking-wider">Learning Rate</span>
                <input type="range" id="lr-slider" min="0.001" max="0.1" step="0.001" value="0.05" class="w-full md:w-32 accent-cyan-500 cursor-pointer">
            </div>

            <div class="hidden md:block h-8 w-px bg-gray-700"></div>

            <button id="btn-step" class="btn-neon px-4 py-2 md:px-6 rounded font-bold flex items-center gap-2 text-xs md:text-base">
                <span>‚ñ∂</span> <span class="hidden md:inline">STEP</span>
            </button>
            
            <button id="btn-train" class="btn-neon px-4 py-2 md:px-6 rounded font-bold flex items-center gap-2 border-amber-500 text-amber-500 hover:shadow-amber-500/50 text-xs md:text-base">
                <span>‚ö°</span> AUTO TRAIN
            </button>

            <div class="hidden md:block h-8 w-px bg-gray-700"></div>

            <button id="btn-reset" class="px-3 py-2 text-[10px] md:text-xs text-red-400 hover:text-red-300 border border-red-900/50 hover:bg-red-900/20 rounded transition">
                RESET
            </button>
        </div>
    </div>

    <!-- CHARTS OVERLAY (Right) -->
    <div class="absolute top-1/2 right-2 md:right-4 transform -translate-y-1/2 z-10 w-40 md:w-64 pointer-events-none">
        <div class="glass-panel p-2 rounded mb-4 pointer-events-auto">
            <div class="text-[10px] text-center text-gray-400 mb-1 uppercase">Gap Analysis</div>
            <canvas id="lossChart" height="100"></canvas>
        </div>
        
        <div id="bias-meter-container" class="glass-panel hazard p-2 rounded pointer-events-auto hidden">
            <div class="text-[10px] text-center text-red-400 font-bold mb-1 uppercase flex items-center justify-center gap-1">
                <span>‚ö†</span> BIAS DETECTED
            </div>
            <div class="w-full bg-gray-800 h-2 rounded overflow-hidden relative">
                <div id="bias-bar" class="h-full bg-red-500 transition-all duration-500" style="width: 100%"></div>
            </div>
            <div class="flex justify-between text-[9px] text-gray-500 mt-1">
                <span>Safe</span>
                <span>Critical</span>
            </div>
            <div class="text-[9px] text-center mt-2 text-gray-400" id="bias-status">
                Dataset: <strong>LEGACY</strong>
            </div>
        </div>
    </div>

    <!-- CANVAS LAYER -->
    <canvas id="gameCanvas" class="w-full h-full absolute top-0 left-0 z-0"></canvas>

    <!-- MODAL / TUTORIAL -->
    <div id="modal-overlay" class="fixed inset-0 bg-black/90 z-50 flex items-center justify-center p-4">
        <div class="glass-panel max-w-2xl w-full p-6 md:p-8 rounded-xl border-2 border-cyan-500/30 relative">
            <div class="absolute -top-3 -left-3 w-6 h-6 border-t-2 border-l-2 border-cyan-400"></div>
            <div class="absolute -bottom-3 -right-3 w-6 h-6 border-b-2 border-r-2 border-cyan-400"></div>
            
            <h2 id="modal-title" class="text-2xl md:text-3xl text-white mb-4 border-b border-gray-700 pb-2">WELCOME ARCHITECT</h2>
            <div id="modal-content" class="text-gray-300 space-y-4 leading-relaxed font-light text-sm md:text-lg">
                <!-- Content injected via JS -->
            </div>
            <div class="mt-8 flex justify-end">
                <button id="modal-btn" class="btn-neon px-6 py-2 md:px-8 md:py-3 text-lg md:text-xl rounded">INITIALIZE SYSTEM</button>
            </div>
        </div>
    </div>

    <!-- LOGIC -->
    <script>
        // --- ENGINE & MATH ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        let logicalWidth, logicalHeight;

        // Activation Functions
        const sigmoid = x => 1 / (1 + Math.exp(-x));
        const sigmoidDeriv = x => x * (1 - x);
        
        // Neural Network Class with Momentum
        class NeuralNetwork {
            constructor(layerSizes) {
                this.layers = [];
                this.layerSizes = layerSizes;
                this.momentum = 0.8;
                
                for (let i = 0; i < layerSizes.length; i++) {
                    const layer = {
                        neurons: new Float32Array(layerSizes[i]),
                        biases: new Float32Array(layerSizes[i]),
                        biasVelocities: new Float32Array(layerSizes[i]), 
                        errors: new Float32Array(layerSizes[i]),
                        gradients: new Float32Array(layerSizes[i]),
                    };
                    for(let j=0; j<layerSizes[i]; j++) layer.biases[j] = Math.random() * 2 - 1;
                    this.layers.push(layer);
                }

                this.weights = [];
                for (let i = 0; i < layerSizes.length - 1; i++) {
                    const rows = layerSizes[i+1];
                    const cols = layerSizes[i];
                    const weightMatrix = [];
                    const velMatrix = [];
                    for(let r=0; r<rows; r++) {
                        const row = new Float32Array(cols);
                        const velRow = new Float32Array(cols);
                        for(let c=0; c<cols; c++) row[c] = Math.random() * 2 - 1;
                        weightMatrix.push(row);
                        velMatrix.push(velRow);
                    }
                    this.weights.push({ values: weightMatrix, velocities: velMatrix });
                }
            }

            forward(inputs) {
                for(let i=0; i<inputs.length; i++) this.layers[0].neurons[i] = inputs[i];

                for(let i=0; i<this.weights.length; i++) {
                    const prevLayer = this.layers[i].neurons;
                    const nextLayer = this.layers[i+1];
                    const weightObj = this.weights[i];

                    for(let j=0; j<nextLayer.neurons.length; j++) {
                        let sum = nextLayer.biases[j];
                        for(let k=0; k<prevLayer.length; k++) {
                            sum += prevLayer[k] * weightObj.values[j][k];
                        }
                        nextLayer.neurons[j] = sigmoid(sum);
                    }
                }
                return this.layers[this.layers.length-1].neurons;
            }

            train(inputs, targets, learningRate) {
                const outputs = this.forward(inputs);
                const outputLayerIdx = this.layers.length - 1;
                const outputLayer = this.layers[outputLayerIdx];
                
                for(let i=0; i<outputLayer.neurons.length; i++) {
                    const error = targets[i] - outputLayer.neurons[i];
                    outputLayer.errors[i] = error;
                    outputLayer.gradients[i] = error * sigmoidDeriv(outputLayer.neurons[i]);
                }

                for(let i = this.weights.length - 1; i >= 0; i--) {
                    const weightObj = this.weights[i];
                    const prevLayer = this.layers[i];
                    const nextLayer = this.layers[i+1];

                    if (i > 0) {
                         for(let j=0; j<prevLayer.neurons.length; j++) {
                             let errorSum = 0;
                             for(let k=0; k<nextLayer.neurons.length; k++) {
                                 errorSum += nextLayer.errors[k] * weightObj.values[k][j];
                             }
                             prevLayer.errors[j] = errorSum;
                             prevLayer.gradients[j] = errorSum * sigmoidDeriv(prevLayer.neurons[j]);
                         }
                    }

                    for(let j=0; j<nextLayer.neurons.length; j++) {
                        for(let k=0; k<prevLayer.neurons.length; k++) {
                            const gradient = nextLayer.gradients[j] * prevLayer.neurons[k];
                            weightObj.velocities[j][k] = (this.momentum * weightObj.velocities[j][k]) + (learningRate * gradient);
                            weightObj.values[j][k] += weightObj.velocities[j][k];
                        }
                        nextLayer.biasVelocities[j] = (this.momentum * nextLayer.biasVelocities[j]) + (learningRate * nextLayer.gradients[j]);
                        nextLayer.biases[j] += nextLayer.biasVelocities[j];
                    }
                }
                
                let sumError = 0;
                for(let i=0; i<outputs.length; i++) sumError += Math.pow(targets[i] - outputs[i], 2);
                return sumError / outputs.length;
            }
        }

        // --- GAME STATE ---
        const Game = {
            level: 1,
            epoch: 0,
            accuracy: 0,
            lossHistory: [],
            isTraining: false,
            wasTraining: false,
            trainingTimer: null,
            learningRate: 0.05,
            nn: null,
            data: [],
            particles: [],
            nodes: [],
            biasScore: 100,
            dataSource: 'legacy',
            
            levels: [
                {
                    id: 1,
                    name: "THE STARTUP",
                    desc: "Establish a simple decision flow. A linear problem.",
                    structure: [2, 1],
                    goalAcc: 95,
                    biasEvent: false
                },
                {
                    id: 2,
                    name: "THE EXPANSION",
                    desc: "The market is complex (XOR). We need a 'Middle Management' layer.",
                    structure: [2, 4, 1], 
                    goalAcc: 90,
                    biasEvent: false
                },
                {
                    id: 3,
                    name: "CULTURE CRISIS",
                    desc: "The structure is fine, but the historical data is biased. Fix the source.",
                    structure: [3, 5, 2],
                    goalAcc: 85,
                    biasEvent: true
                }
            ],

            initLevel: function(lvlIdx) {
                this.stopTraining();
                this.level = lvlIdx + 1;
                const config = this.levels[lvlIdx];
                this.nn = new NeuralNetwork(config.structure);
                this.epoch = 0;
                this.lossHistory = [];
                this.particles = [];
                this.biasScore = 100;
                this.dataSource = 'legacy'; 
                this.genData(config);
                
                // UI Updates
                document.getElementById('level-title').innerText = `LEVEL ${this.level}: ${config.name}`;
                document.getElementById('level-desc').innerText = config.desc;
                
                if(config.biasEvent) {
                    document.getElementById('objective-container').innerText = `GOAL: BIAS < 5% & ACC > 75%`;
                    document.getElementById('bias-meter-container').classList.remove('hidden');
                    document.getElementById('data-controls').classList.remove('hidden');
                    document.getElementById('data-controls').classList.add('flex');
                    this.updateDataButtons();
                } else {
                    document.getElementById('objective-container').innerText = `GOAL: ACCURACY > ${config.goalAcc}%`;
                    document.getElementById('bias-meter-container').classList.add('hidden');
                    document.getElementById('data-controls').classList.add('hidden');
                    document.getElementById('data-controls').classList.remove('flex');
                }

                // Clear chart dataset to prevent "jumps"
                if(lossChart) {
                    lossChart.data.labels = [];
                    lossChart.data.datasets[0].data = [];
                    lossChart.update();
                }

                this.setupVisualNodes();
                updateChart();
            },

            stopTraining: function() {
                this.isTraining = false;
                if(this.trainingTimer) clearTimeout(this.trainingTimer);
                this.updateButtons();
            },

            genData: function(config) {
                this.data = [];
                const isLevel3 = config.id === 3;
                const count = isLevel3 ? 100 : 50;

                for(let i=0; i<count; i++) {
                    if(config.id === 1) {
                        const a = Math.round(Math.random());
                        const b = Math.round(Math.random());
                        this.data.push({ input: [a, b], output: [a && b ? 1 : 0] });
                    } else if (config.id === 2) {
                        const a = Math.round(Math.random());
                        const b = Math.round(Math.random());
                        this.data.push({ input: [a, b], output: [a !== b ? 1 : 0] });
                    } else if (config.id === 3) {
                        const merit = Math.random();
                        const pClass = Math.random() > 0.8 ? 1 : 0; 
                        let decision;
                        if(this.dataSource === 'legacy') {
                            if(pClass === 1) decision = (merit > 0.9) ? 1 : 0;
                            else decision = (merit > 0.4) ? 1 : 0;
                        } else {
                            decision = (merit > 0.5) ? 1 : 0;
                        }
                        this.data.push({ input: [merit, Math.random(), pClass], output: [decision] });
                    }
                }
            },

            setDataSource: function(source) {
                this.dataSource = source;
                this.genData(this.levels[this.level-1]);
                this.updateDataButtons();
                const statusEl = document.getElementById('bias-status');
                if(source === 'audited') statusEl.innerHTML = "Dataset: <strong class='text-green-400'>AUDITED</strong>";
                else statusEl.innerHTML = "Dataset: <strong class='text-red-400'>LEGACY</strong>";
            },

            updateDataButtons: function() {
                const btnLeg = document.getElementById('btn-data-legacy');
                const btnAud = document.getElementById('btn-data-audit');
                if(this.dataSource === 'legacy') {
                    btnLeg.classList.add('active-danger');
                    btnLeg.classList.remove('opacity-50');
                    btnAud.classList.remove('active');
                    btnAud.classList.add('opacity-50');
                } else {
                    btnAud.classList.add('active');
                    btnAud.classList.remove('opacity-50');
                    btnLeg.classList.remove('active-danger');
                    btnLeg.classList.add('opacity-50');
                }
            },

            setupVisualNodes: function() {
                if(!logicalWidth || !logicalHeight) return;
                this.nodes = [];
                const layers = this.nn.layerSizes;
                const layerGap = logicalWidth / (layers.length + 1);
                
                // Safe Zone Calculation - Dynamic to fit content
                const headerEl = document.getElementById('ui-header');
                const footerEl = document.getElementById('ui-footer');
                const headerH = headerEl ? headerEl.offsetHeight : 120;
                const footerH = footerEl ? footerEl.offsetHeight : 120;
                
                const availableH = logicalHeight - headerH - footerH;
                const startYBase = headerH; 

                for(let l=0; l<layers.length; l++) {
                    const count = layers[l];
                    // Smaller gaps on landscape mobile
                    const gap = Math.min(60, availableH / (count + 0.5)); 
                    const totalColH = (count - 1) * gap;
                    const topY = startYBase + (availableH / 2) - (totalColH / 2);
                    
                    for(let n=0; n<count; n++) {
                        this.nodes.push({
                            x: layerGap * (l + 1),
                            y: topY + (n * gap),
                            layer: l,
                            index: n
                        });
                    }
                }
            },

            trainBatch: function(animate = true) {
                let totalLoss = 0;
                let correct = 0;
                
                this.data.sort(() => Math.random() - 0.5);

                this.data.forEach(item => {
                    const loss = this.nn.train(item.input, item.output, this.learningRate);
                    totalLoss += loss;
                    const output = this.nn.layers[this.nn.layers.length-1].neurons[0];
                    const prediction = output > 0.5 ? 1 : 0;
                    if(prediction === item.output[0]) correct++;
                });

                const avgLoss = totalLoss / this.data.length;
                this.lossHistory.push(avgLoss);
                if(this.lossHistory.length > 50) this.lossHistory.shift();
                
                this.accuracy = (correct / this.data.length) * 100;
                this.epoch++;

                if(this.levels[this.level-1].biasEvent) {
                    if(this.dataSource === 'legacy') this.biasScore = Math.max(80, this.biasScore - 0.1);
                    else this.biasScore = Math.max(0, this.biasScore - 1.5);
                    document.getElementById('bias-bar').style.width = this.biasScore + "%";
                }

                if(animate) {
                    this.spawnParticles('forward');
                    setTimeout(() => this.spawnParticles('backward'), 300);
                }

                this.checkWin();
            },

            spawnParticles: function(type) {
                if(this.particles.length > 500) return;
                
                const weights = this.nn.weights;
                for(let l=0; l<weights.length; l++) {
                    const currentNodes = this.nodes.filter(n => n.layer === l);
                    const nextNodes = this.nodes.filter(n => n.layer === l+1);
                    
                    for(let i=0; i<currentNodes.length; i++) {
                        for(let j=0; j<nextNodes.length; j++) {
                            const w = weights[l].values[j][i];
                            // Visual culling
                            if(Math.abs(w) > 0.1 || Math.random() > 0.9) {
                                const start = type === 'forward' ? currentNodes[i] : nextNodes[j];
                                const end = type === 'forward' ? nextNodes[j] : currentNodes[i];
                                
                                this.particles.push({
                                    x: start.x,
                                    y: start.y,
                                    tx: end.x,
                                    ty: end.y,
                                    progress: 0,
                                    speed: 0.05 + Math.random() * 0.05,
                                    color: type === 'forward' ? '#0aff00' : '#ffffff',
                                    size: type === 'forward' ? 2 : 3
                                });
                            }
                        }
                    }
                }
            },

            checkWin: function() {
                const config = this.levels[this.level - 1];
                let won = false;
                
                if(config.biasEvent) {
                    // Critical Fix: Must be accurate AND fair
                    if(this.biasScore < 5 && this.accuracy > 75) won = true;
                } else {
                    if(this.accuracy >= config.goalAcc) won = true;
                }

                if(won) {
                    this.stopTraining();
                    
                    if(this.level < 3) {
                        showModal(`LEVEL ${this.level} COMPLETE`, 
                            `Performance Gap closed. The system is stable.<br>Ready to expand complexity?`, 
                            "NEXT LEVEL", 
                            () => this.initLevel(this.level));
                    } else {
                        showModal("CERTIFICATION COMPLETE", 
                            "You have successfully navigated Architecture, Training, and Ethical Alignment.<br>The Cognitive Division is ready.", 
                            "RESTART SIMULATION", 
                            () => location.reload());
                    }
                }
            },

            updateButtons: function() {
                const btnTrain = document.getElementById('btn-train');
                const btnStep = document.getElementById('btn-step');
                
                if(this.isTraining) {
                    btnTrain.innerHTML = "<span>‚è∏</span> PAUSE";
                    btnTrain.classList.add('animate-pulse');
                    btnStep.disabled = true;
                } else {
                    btnTrain.innerHTML = "<span>‚ö°</span> AUTO TRAIN";
                    btnTrain.classList.remove('animate-pulse');
                    btnStep.disabled = false;
                }
            }
        };

        // --- VISUALIZATION LOOP ---
        function resize() {
            const dpr = window.devicePixelRatio || 1;
            logicalWidth = window.innerWidth;
            logicalHeight = window.innerHeight;
            
            canvas.width = logicalWidth * dpr;
            canvas.height = logicalHeight * dpr;
            
            ctx.scale(dpr, dpr);
            
            if(Game.nn) {
                Game.setupVisualNodes();
                Game.particles = [];
            }
        }
        window.addEventListener('resize', resize);

        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                Game.wasTraining = Game.isTraining;
                Game.stopTraining();
            }
        });

        function draw() {
            ctx.fillStyle = '#050510';
            ctx.fillRect(0, 0, logicalWidth, logicalHeight);

            if(!Game.nn) return requestAnimationFrame(draw);

            // Draw Weights
            for(let l=0; l<Game.nn.weights.length; l++) {
                const currentNodes = Game.nodes.filter(n => n.layer === l);
                const nextNodes = Game.nodes.filter(n => n.layer === l+1);
                
                for(let i=0; i<currentNodes.length; i++) {
                    for(let j=0; j<nextNodes.length; j++) {
                        const weight = Game.nn.weights[l].values[j][i];
                        const from = currentNodes[i];
                        const to = nextNodes[j];
                        
                        ctx.beginPath();
                        ctx.moveTo(from.x, from.y);
                        ctx.lineTo(to.x, to.y);
                        
                        const strength = Math.abs(weight);
                        ctx.lineWidth = Math.min(6, Math.max(0.2, strength * 2));
                        
                        if(weight > 0) ctx.strokeStyle = `rgba(0, 243, 255, ${Math.min(0.3, strength)})`;
                        else ctx.strokeStyle = `rgba(255, 0, 80, ${Math.min(0.3, strength)})`;
                        
                        ctx.stroke();
                    }
                }
            }

            // Draw Particles
            for(let i=Game.particles.length-1; i>=0; i--) {
                const p = Game.particles[i];
                p.progress += p.speed;
                
                const currX = p.x + (p.tx - p.x) * p.progress;
                const currY = p.y + (p.ty - p.y) * p.progress;
                
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(currX, currY, p.size, 0, Math.PI*2);
                ctx.fill();

                if(p.progress >= 1) Game.particles.splice(i, 1);
            }

            // Draw Nodes
            Game.nodes.forEach(node => {
                const val = Game.nn.layers[node.layer].neurons[node.index];
                
                ctx.beginPath();
                ctx.arc(node.x, node.y, 12, 0, Math.PI*2);
                ctx.fillStyle = '#0f172a';
                ctx.fill();
                
                ctx.lineWidth = 2;
                ctx.strokeStyle = node.layer === 0 ? '#fbbf24' : (node.layer === Game.nn.layers.length-1 ? '#a3e635' : '#00f3ff');
                ctx.stroke();

                if(val > 0.1) {
                    ctx.beginPath();
                    ctx.arc(node.x, node.y, 12 * val, 0, Math.PI*2);
                    ctx.fillStyle = `rgba(255, 255, 255, ${val * 0.6})`;
                    ctx.fill();
                }
            });

            // HUD
            document.getElementById('epoch-display').innerText = Game.epoch;
            const lastLoss = Game.lossHistory.length > 0 ? Game.lossHistory[Game.lossHistory.length-1] : 0;
            document.getElementById('loss-display').innerText = lastLoss.toFixed(3);
            document.getElementById('acc-display').innerText = Math.round(Game.accuracy) + "%";

            requestAnimationFrame(draw);
        }

        // --- UI BINDINGS ---
        const modal = document.getElementById('modal-overlay');
        const modalTitle = document.getElementById('modal-title');
        const modalContent = document.getElementById('modal-content');
        const modalBtn = document.getElementById('modal-btn');

        function showModal(title, content, btnText, action) {
            modalTitle.innerText = title;
            modalContent.innerHTML = content;
            modalBtn.innerText = btnText;
            modalBtn.onclick = () => {
                modal.classList.add('hidden');
                if(action) action();
            };
            modal.classList.remove('hidden');
        }

        // Chart
        const ctxChart = document.getElementById('lossChart').getContext('2d');
        let lossChart = new Chart(ctxChart, {
            type: 'line',
            data: {
                labels: [],
                datasets: [{
                    data: [],
                    borderColor: '#00f3ff',
                    borderWidth: 1.5,
                    tension: 0.1,
                    pointRadius: 0
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: { x: { display: false }, y: { display: false } },
                plugins: { legend: { display: false } },
                animation: false
            }
        });

        function updateChart() {
            lossChart.data.labels = Game.lossHistory.map((_, i) => i);
            lossChart.data.datasets[0].data = Game.lossHistory;
            lossChart.update();
        }

        // Controls
        document.getElementById('btn-step').addEventListener('click', () => {
            Game.trainBatch(true);
            updateChart();
        });

        document.getElementById('btn-train').addEventListener('click', () => {
            Game.isTraining = !Game.isTraining;
            Game.updateButtons();
            if(Game.isTraining) loopTraining();
            else if(Game.trainingTimer) clearTimeout(Game.trainingTimer);
        });

        function loopTraining() {
            if(!Game.isTraining) return;
            Game.trainBatch(true);
            updateChart();
            Game.trainingTimer = setTimeout(loopTraining, 150);
        }

        document.getElementById('btn-reset').addEventListener('click', () => {
            Game.stopTraining();
            Game.initLevel(Game.level - 1);
        });

        document.getElementById('lr-slider').addEventListener('input', (e) => {
            Game.learningRate = parseFloat(e.target.value);
        });

        // Initialize
        resize();
        modalContent.innerHTML = `
            <p>You have been hired to design the <strong class="text-white">Cognitive Division</strong>.</p>
            <p>Your goal: Build a synthetic organization (Neural Network) that learns from data.</p>
            <ul class="list-disc pl-5 space-y-2 text-cyan-200 mt-4">
                <li><strong>Architecture:</strong> The Org Chart (Nodes & Layers).</li>
                <li><strong>Weights:</strong> Relationships & Trust (Lines).</li>
                <li><strong>Training:</strong> The cycle of Action and Feedback.</li>
            </ul>
        `;
        
        modalBtn.onclick = () => {
            modal.classList.add('hidden');
            Game.initLevel(0);
            draw();
        };

    </script>
</body>
</html>
